| Prompt | Answer |
|--- |--- |
|What classes does each implementation include? Are the lists the same?| They both have the same classes|
|Write down a sentence to describe each class.|CartEntry is the template for a single cart entry item's unit price and number added to the cart.  ShoppingCart contains all the info you can get from looking at a shopping cart, ie. how many CartEntries there are, and from there, how many of each and their price. Order contains how much the total order costs and initializes an empty shopping cart. |
|How do the classes relate to each other? It might be helpful to draw a diagram on a whiteboard or piece of paper.|In implementation A, the total cost of the order is calculated with what is basically a train wreck by telling the cart and cart entries how to return back the subtotal. In implementation B, the calculation is basically spread out among the classes so that each returns the piece of information it should be responsible for calculating or giving. Finally, total_price only asks the cart to tell its subtotal, and the Order class knows how much sales tax is, so it only needs to add the sales tax to the subtotal.|
|What data does each class store? How (if at all) does this differ between the two implementations?| drawing a diagram of both implementations helped me see that each essentially stores the same data, but provides it in better formats in implementation B. |
|What methods does each class have? How (if at all) does this differ between the two implementations?| The methods are different between the two implementations, this is how the data is provided and accessed by other classes - the methods basically access their own data to provide data to other methods in a ready-to-use format.|
|Consider the Order#total_price method. In each implementation: Is logic to compute the price delegated to "lower level" classes like ShoppingCart and CartEntry, or is it retained in Order? Does total_price directly manipulate the instance variables of other classes?| In implementation A, logic to compute the price is determined by the total_price method directly accessing the instance variables of other classes. In implementation B, it accesses instead the return value of only Cart's price method to get the subtotal, and Cart gets its entry prices by asking each CartEntry for the info, without going directly into each CartEntry's instance variables.|
|If we decide items are cheaper if bought in bulk, how would this change the code? Which implementation is easier to modify?| If we decide items are cheaper bought in bulk and were working with implementation A, we would have to put all of the logic into the Order total_price method, which would check the quantity of each CartEntry and do changes if necessary. It is easier to modify implementation B's CartEntry class since it can be done in the price method.|
|Which implementation better adheres to the single responsibility principle?|Implementation B definitely adheres better to the single responsibility principle since there is never any overreaching method that accesses another's instance variables.|
|Bonus question once you've read Metz ch. 3: Which implementation is more loosely coupled?| Definitely implementation B since each class doesn't really know how the other one functions internally, they are able to work together by asking each other for information and not telling eachother how to work or relying on another's instance variables from outside of the class.|

## Hotel Refactor
#### Where does a class take on multiple roles, or directly modify the attributes of another class?
Room's function is to be a room with a rate, number, and list of reservations and blocks it has. It currently also has to say if it is available for a given date range by looking at its own reservation and block check-in, check-out dates. Room.status() tells both reservations AND blocks _how_ to determine if thre is a check-in/check-out conflict by accessing their instance variables. It should instead just ask each block and reservation if they are available for given date ranges. To change it, I would have to basically move the logic from Room into both Reservation and Block, but since it's basically the same logic for each, I would rather only write it in one location, so I'll make a new DateRange class that deals with the logic and just returns true or false if there's either a check-in conflict or a check-out conflict, and Room will still say whether its status is :AVAILABLE or :UNAVAILABLE. This will be an improvement on single responsibility and the same thing won't need to be written twice anywhere.
